import {
  type DrawDocumentCollectionEntity,
  type DrawDocumentEntity,
  createDrawDocumentCollectionEntity,
  createDrawDocumentEntity,
  deleteDrawDocumentEntity,
  generateDocumentCollectionId,
  generateDocumentId,
  getDrawDocumentCollectionEntity,
  getDrawDocumentEntities,
  listDrawDocumentEntitiesByWorkflowNodeIds,
} from "@/dynamo/draw-document";
import { DynamoDBTypename } from "@/dynamo/dynamo";
import { generateDocumentS3Key } from "@/s3/draw-document";
import { generatePresignedDownloadUrl, generatePresignedUploadUrl } from "@/s3/s3";
import { GraphQLTypename } from "@/service/graphql";
import type { Token } from "@aspira-nextgen/core/authn";
import { buildCreateMetadata } from "@aspira-nextgen/core/dynamodb";
import {
  type DeleteDrawDocumentInput,
  type DrawDocument,
  type DrawDocumentCollectionDownload,
  type DrawDocumentDownload,
  DrawDocumentProcessingStatus,
  type DrawDocumentUpload,
  type PrepareDrawUploadInput,
} from "@aspira-nextgen/graphql/resolvers";

export const prepareDrawDocumentUpload = async (
  input: PrepareDrawUploadInput,
  token: Token,
): Promise<DrawDocumentUpload> => {
  const organizationId = token.claims.organizationId;

  if (input.contentType !== "text/csv") {
    throw new Error("Only CSV files are supported.");
  }

  const drawDocumentEntity = await createDrawDocument(
    {
      ...input,
      processingStatus: DrawDocumentProcessingStatus.UrlGenerated,
      createdBy: token.sub,
    },
    organizationId,
  );

  const url = await generatePresignedUploadUrl(drawDocumentEntity.s3Key, input.contentType);

  return {
    document: {
      ...drawDocumentEntity,
      __typename: DynamoDBTypename.DRAW_DOCUMENT,
    },
    url,
    __typename: "DrawDocumentUpload",
  };
};

export const prepareDrawDocumentDownload = async (documentId: string, token: Token): Promise<DrawDocumentDownload> => {
  const organizationId = token.claims.organizationId;

  const [drawDocumentEntity] = await getDrawDocumentEntities([documentId], organizationId);

  if (!drawDocumentEntity) {
    throw new Error("Document not found.");
  }

  const url = await generatePresignedDownloadUrl(drawDocumentEntity.s3Key);

  return {
    document: {
      ...drawDocumentEntity,
      __typename: DynamoDBTypename.DRAW_DOCUMENT,
    },
    url,
    __typename: "DrawDocumentDownload",
  };
};

export const getDrawDocuments = async (documentIds: string[], organizationId: string): Promise<DrawDocument[]> => {
  const entities = await getDrawDocumentEntities(documentIds, organizationId);

  return entities.map((entity) => ({
    ...entity,
    __typename: DynamoDBTypename.DRAW_DOCUMENT,
  }));
};

export const getDrawDocument = async (documentId: string, organizationId: string): Promise<DrawDocument> => {
  const [doc] = await getDrawDocuments([documentId], organizationId);

  if (!doc) {
    throw new Error("Document not found.");
  }

  return doc;
};

/**
 * An internal method to create a draw document. This method is not exposed to the API and
 * can be used to create draw documents that are generated by the system. Documents created
 * in the ValidationFinished status will be ignored by the SQS queue.
 */
export const createDrawDocument = async (
  input: PrepareDrawUploadInput & {
    processingStatus: DrawDocumentProcessingStatus;
    createdBy: string;
  },
  organizationId: string,
): Promise<DrawDocumentEntity> => {
  // Generating these values here to avoide a chicken-and-egg problem with the S3 key.
  const documentId = generateDocumentId();
  const s3Key = generateDocumentS3Key(organizationId, documentId, input.filename);

  // Will validate that the filename is unique.
  const entity = await createDrawDocumentEntity(
    {
      id: documentId,
      s3Key,
      ...input,
      ...buildCreateMetadata(input.createdBy),
    },
    organizationId,
  );

  return {
    ...entity,
    __typename: DynamoDBTypename.DRAW_DOCUMENT,
  };
};

/**
 * An internal method to create a draw document collection. This method is not exposed to the API and
 * can be used to create draw document collections that are generated by the system. These will be
 * ignored by the SQS queue.
 */
export const createDrawDocumentCollection = async (
  input: {
    name: string;
    filename: string;
    contentType: string;
  },
  organizationId: string,
): Promise<DrawDocumentCollectionEntity> => {
  const documentId = generateDocumentCollectionId();

  const s3Key = generateDocumentS3Key(organizationId, documentId, input.filename);

  const entity = await createDrawDocumentCollectionEntity(
    {
      id: documentId,
      s3Key,
      ...input,
      ...buildCreateMetadata("system"),
    },
    organizationId,
  );

  return {
    ...entity,
    __typename: DynamoDBTypename.DRAW_DOCUMENT_COLLECTION,
  };
};

export const prepareDrawDocumentCollectionDownload = async (
  documentCollectionId: string,
  token: Token,
): Promise<DrawDocumentCollectionDownload> => {
  const organizationId = token.claims.organizationId;

  const drawDocumentCollectionEntity = await getDrawDocumentCollectionEntity({ documentCollectionId, organizationId });

  if (!drawDocumentCollectionEntity) {
    throw new Error("Document collection not found.");
  }

  const url = await generatePresignedDownloadUrl(drawDocumentCollectionEntity.s3Key);

  return {
    url,
    __typename: GraphQLTypename.DRAW_DOCUMENT_COLLECTION_DOWNLOAD,
  };
};

export const getDrawDocumentByWorkflowNodeId = async (input: {
  workflowNodeId: string;
  organizationId: string;
}): Promise<DrawDocument | null> => {
  const { workflowNodeId, organizationId } = input;

  const entities = await listDrawDocumentEntitiesByWorkflowNodeIds({
    workflowNodeIds: [workflowNodeId],
    organizationId,
  });

  const entity = entities[0];
  if (!entity) {
    return null;
  }

  return entity;
};

export const deleteDrawDocument = async (input: DeleteDrawDocumentInput, token: Token): Promise<boolean> => {
  const { organizationId } = token.claims;
  return await deleteDrawDocumentEntity({ organizationId, documentId: input.id });
};
